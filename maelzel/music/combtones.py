from __future__ import annotations
from collections import namedtuple as _namedtuple
from emlib.containers import RecordList 
from pitchtools import f2n, n2f, m2n, f2m, m2f, interval2ratio
from emlib import misc
from emlib.mathlib import frange
import emlib.iterlib
from itertools import combinations
from maelzel.core import Note, Chord, asNote, Chain
from math import sqrt, ceil
from maelzel.common import *
from typing import Callable, NamedTuple, List, Optional as Opt, Union


# ------------------------------------------------------------
#     COMBINATION TONES
# ------------------------------------------------------------

    
pitch_t = Union[int, float, str, Note]


def _ringmod2f(f1: float, f2: float) -> Tuple[float, float]:
    """
    Calculate the difference and combination freqs. between f1 and f2
    """
    comb = f1+f2
    diff = max(9., abs(f1-f2))
    return diff, comb


def _parsePitches(*pitches) -> List[float]:
    midis = []
    for p in pitches:
        if isinstance(p, str):
            midis.extend(map(n2m, p.split()))
        elif isinstance(p, (Note, int, float)):
            midis.append(asmidi(p))
        elif isinstance(p, (list, tuple)):
            midis.extend(_parsePitches(*p))
        else:
            raise TypeError(p)
    return midis


def ringmod(*pitches: pitch_t) -> List[Note]:
    """
    Calculate the ring-modulation between the given notes

    pitches:
        a midinote, a notename or a Note (no frequencies!)
        Many notenames can be given as one string, separated by spaces

    Returns the notes of the sidebands, as Notes
    """
    for p in pitches:
        _checkpitch(p)
    midinotes = _parsePitches(*pitches)
    freqs = list(map(m2f, midinotes))
    sidebands = [_ringmod2f(f1, f2) for f1, f2 in combinations(freqs, 2)]
    all_sidebands = list(set(emlib.iterlib.flatten(sidebands)))
    all_sidebands.sort()
    return [Note(f2m(sideband)) for sideband in all_sidebands]

def sumtones(*pitches: pitch_t) -> List[Note]:
    """
    Calculate the summation tones generated by all the pair combinations of notes
    
    pitches: a seq. of Notes
    notes: a seq of notes as strings "C4", "C5+", etc. or frequencies.
    """
    midis = _parsePitches(pitches)
    freqs = list(map(m2f, midis))
    return [Note(f2m(f1+f2)) for f1, f2 in combinations(freqs, 2)]
    

class Difftone:  
    _fields = ("note0", "note1", "freq0", "freq1", "diff", "freq", "desired", "beating")

    def __init__(self, note0:pitch_t, note1:pitch_t, desired:pitch_t=None):
        self.note0: Note = asNote(note0)
        self.note1: Note = asNote(note1)
        self.freq0: float = round(self.note0.freq)
        self.freq1: float = round(self.note1.freq)
        self.diff: Note = Note(f2m(abs(self.note0.freq - self.note1.freq)))
        self.desired: Note = asNote(desired) if desired is not None else self.diff
        self.beatings:int = round(abs(self.desired.freq - self.diff.freq))
        self._notes = None

    @property
    def notes(self):
        if self._notes is None:
            self._notes = Chord(self.note0, self.note1)
        return self._notes

    def __iter__(self):
        # these correspond to _fields
        return iter((self.note0, self.note1, self.freq0, self.freq1, self.diff,
                     round(self.diff.freq), self.desired, self.beatings))

    def __repr__(self):
        if self.desired == self.diff:
            return f"Difftone(note0={self.note0}, note1={self.note1}, diff={self.diff})"
        return f"Difftone(note0={self.note0}, note1={self.note1}, diff={self.diff}, desired={self.desired}, beatings={self.beatings})"
        
    def transpose(self, interval:float) -> Difftone:
        note0 = self.note0 + interval
        note1 = self.note1 + interval 
        return Difftone(note0, note1)

    def asChord(self, diff=True) -> Chord:
        """
        diff: if True, the resulting difftone is included in the chord
        """
        if diff:
            ch = Chord(self.note0, self.note1, self.diff)
        else:
            ch = Chord(self.note0, self.note1)
        return ch

    def show(self) -> None:
        ch = self.asChord(diff=True)
        ch.show()

    def play(self, *args, **kws):
        return self.asChord(diff=False).play(*args, **kws)

    def shiftRatio(self, result):
        """
        Find a ratio r to multiply the freq. of the sources of this difftone so
        that they produce a difftone `result`

        NB: if note1 and note2 produce a difftone d, when note1 and note2
            both are transposed by the same interval i, the resulting 
            difftone is also transposed by the same interval i

        Example

        d = difftone_source("A3", interval=1)
        """
        return interval2ratio(self.diff.pitch - asmidi(result))


def difftones(*pitches: pitch_t) -> List[Note]:
    """
    Calculate the difference tones generated by all possible pairs

    See Also
    ~~~~~~~~

    difftones_sources, difftone_sources_in_range
    """
    midis = _parsePitches(*pitches)
    freqs = [m2f(m) for m in midis]
    return [Note(f2m(abs(f2 - f1))) for f1, f2 in combinations(freqs, 2)]
    

def difftones_cubic(*notes:pitch_t) -> List[Note]:
    """
    Return the cubic difference tones
    
    if f1 and f2 are pure tones and f1 < f2, the cubic diff-tone is
    
    2*f1 - f2
    """
    freqs = [m2f(asmidi(note)) for note in notes]
    out = []
    for f1, f2 in combinations(freqs, 2):
        if f2 < f1:
            f1, f2 = f2, f1
        f0 = f1*2 - f2
        out.append(Note(f2m(f0)))
    return out


def difftone_source(difftone:pitch_t, interval:float, resolution=0.0) -> Difftone:
    """
    Args:

        difftone: the resulting difftone
        interval: the interval between the two notes which should produce a
            difference tone close to `difftone`
        resolution: the resolution of the pitch grid for the source notes. This
            also defines the acceptable error of the resulting difftone

    Returns:
        a Difftone
    """

    diffFreq = m2f(asmidi(difftone))
    ratio = interval2ratio(interval)
    f0 = diffFreq / (ratio - 1)
    f1 = f0 * ratio
    midi0, midi1 = f2m(f0), f2m(f1)
    if resolution > 0:
        midi0 = misc.snap_to_grid(midi0, resolution)
        midi1 = misc.snap_to_grid(midi1, resolution)
    return Difftone(midi0, midi1, difftone)


def _difftone_find_source(pitch, maxdeviation=0.5, intervals=None,
                          minnote:pitch_t= 'A0', maxnote:pitch_t= 'C8', resolution=1.
                          ) -> List[Tuple[float, float]]:
    """

    Args:
        pitch: the resulting difftone
        maxdeviation: the max. deviation between the generated difftone
            and the desired one
        intervals: a list of possible intervals (None to allow any interval)
        minnote: the lowest note to search
        maxnote: the highest note to search
        resolution: the pitch resolution of the search space (1=semitone)

    Returns:
        a list of (lowest note, highest note))
    """
    pitch = asmidi(pitch)
    pitchfreq = m2f(pitch)
    intervals = intervals or list(frange(resolution, 8, resolution))
    f0 = m2f(pitch-maxdeviation)
    f1 = m2f(pitch+maxdeviation)
    minmidi = asmidi(minnote)
    maxmidi = asmidi(maxnote)
    out = []
    for interval in intervals:
        for m0 in frange(minmidi, maxmidi+resolution, resolution):
            m1 = m0 + interval
            if m1 >= maxmidi+resolution:
                continue
            diffFreq = abs(m2f(m0) - m2f(m1))
            if diffFreq > f1:
                break
            elif f0 <= diffFreq <= f1:
                out.append((abs(diffFreq - pitchfreq), (m0, m1)))
    if out:
        out.sort()
        out = [pair for error, pair in out]
        out.sort()
    return out


def _sumtone_find_source(pitch, maxdist=0.5, intervals:List[Union[int, float]]=None,
                         minnote:pitch_t= 'A0', maxnote:pitch_t= 'C8', difftonegap=0.):
    """
    pitch: a note str or a midinote
    maxdist: the max. distance between the given note and #
                 the produced sumtone
    intervals: allowed intervals for the source pitches
    minnote, maxnote: the range to look for sumtones

    Returns: a list of pairs (note1:str, note2:str) representing
             notes which produce
             the given pitch as a sumtone
             (or an empty list if no pairs are found)
    """
    intervals = intervals or [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    m0 = asmidi(pitch)
    midimin = int(n2m(minnote)) if isinstance(minnote, str) else int(minnote)
    midimax = int(n2m(maxnote)) if isinstance(maxnote, str) else int(maxnote)
    minValidFreq = 1
    results = []
    for interval in intervals:
        for midi1 in range(midimin, midimax):
            midi2 = midi1 + interval
            if midi2 > midimax:
                continue
            sumFreq = m2f(midi1) + m2f(midi2)
            if sumFreq <= minValidFreq:
                continue
            diffFreq = abs(m2f(midi1) - m2f(midi2))
            if diffFreq < 20 or (abs(f2m(diffFreq) - f2m(sumFreq)) < difftonegap):
                continue
            midiError = abs(f2m(sumFreq) - m0)
            if midiError <= maxdist:
                results.append((midiError, (midi1, midi2)))
    if not results:
        return []
    results.sort()  # secondary sort by minimal difference
    pairs = list(set(midipair for diff, midipair in results))
    pairs.sort()    # primary sort by pitch
    out = [(m2n(m1), m2n(m2)) for m1, m2 in pairs]
    assert all(isinstance(n0, str) and isinstance(n1, str) for n0, n1 in out)
    return out


def difftone_sources_from_set(difftone: pitch_t,
                              sources: List[T],
                              tomidi: Callable[[T], float] = asmidi,
                              maxdeviation=0.5,
                              exclude_intervals=None,
                              exclude_intervals_maxdeviation=0.5,
                              gap=0) -> List[Tuple[T, T]]:
    difftone_pitch = asmidi(difftone)
    f0 = m2f(difftone_pitch - maxdeviation)
    f1 = m2f(difftone_pitch + maxdeviation)
    possible_sources = [source for source in sources if tomidi(source) >= difftone_pitch + gap]
    results = []
    for s1, s2 in combinations(possible_sources, 2):
        p1 = tomidi(s1)
        p2 = tomidi(s2)
        if p1 > p2:
            p1, p2 = p2, p1
            s1, s2, = s2, s1
        ok = True
        if exclude_intervals:
            interval_now = abs(p1 - p2)
            for excluded in exclude_intervals:
                if abs(interval_now - excluded) < exclude_intervals_maxdeviation:
                    ok = False
                    break
        if not ok:
            continue
        diff_freq = abs(m2f(p1) - m2f(p2))
        if f0 <= diff_freq <= f1:
            results.append((s1, s2))
    results.sort(key=lambda pair: tomidi(pair[0]))
    return results


def difftone_sources(result: pitch_t,
                     maxdist=0.5,
                     gap=13.0,
                     minnote: pitch_t = None,
                     maxnote: pitch_t = "C8",
                     intervals: List[number_t] = None,
                     resolution=1.,
                     display=False
                     ) -> RecordList:
    """
    Find two notes which produce a difference tone near the given note

    Args:
        result: the resulting difference tone, as Note, notename or midinote
        maxdist: the maximum distance between the expected result and the generated tone,
            in semitones (0.5 == 50 cents)
        gap: the distance between the resulting difference tone and the lowest of
            the two originating notes
        minnote: the min. note to considere as a source
        maxnote: the max. note to considere as a source
        intervals: accepted intervals between the notes. If None is given, a set of intervals
            based on resolution is used
        resolution: the resolution of the pitch grid, in semitones. A resolution of 1 will
            search for the given difftone along all semitones between minnote and
            maxnote
        display: if True, the result is printed

    Returns:
        a List of Difftones
    """
    midiresult = asmidi(result)
    maxnote = asmidi(maxnote)
    minnote = minnote or midiresult + gap
    if minnote is None:
        minnote = midiresult + gap
    else:
        minnote = max(minnote, midiresult+gap)
    assert maxnote > minnote
    intervals = intervals or list(frange(resolution, 7, resolution))
    pairs = _difftone_find_source(result, maxdist, minnote=minnote,
                                  maxnote=maxnote, intervals=intervals,
                                  resolution=resolution)
    difftones = [Difftone(note0=Note(midi0), note1=Note(midi1), desired=Note(midiresult))
                 for midi0, midi1 in pairs]
    reclist = RecordList(difftones, fields=Difftone._fields)
    if display:
        # ipython?
        chordseq = Chain([Chord(diff.note0, diff.note1, diff.diff) for diff in difftones])
        chordseq.show()
        if misc.inside_jupyter():
            disp = _jupyter_display()
            disp(reclist)
        else:
            print(reclist)
    return reclist


def _jupyter_display() -> Opt[Callable]:
    if not misc.inside_jupyter():
        return None
    from IPython.display import display
    return display
    

def ringmod_exactsource(sideband1: pitch_t, sideband2: pitch_t
                        ) -> Tuple[Note, Note]:
    """
    Find a pair of frequencies which produce the given sidebands when ringmodulated

    Args:
        sideband1, sideband2: the sidebands produced, as notename or midinote

    Returns:
        the original pitches, as midinotes
    """
    diffFreq = m2f(asmidi(sideband1))
    sumFreq = m2f(asmidi(sideband2))
    f1 = (diffFreq + sumFreq)/2.0
    f0 = sumFreq - f1
    return Note(f2m(f0)), Note(f2m(f1))
    

def _matchone(orig, new, maxdiff):
    """
    match at most one item from new with one item from orig

    orig, new and maxdiff should all have the same unit (freq, midi, etc)
    """
    mindiffs = {}
    matches = {}
    for o, n in emlib.iterlib.product(orig, new):
        diff = abs(o-n)
        if diff < maxdiff and diff < mindiffs.get(o, float('inf')):
            mindiffs[o] = diff
            matches[o] = n
    if not matches:
        return []
    return matches.items()


def ringmod_sources(sidebands: pitch_t,
                    minnote:pitch_t= "A0",
                    maxnote:pitch_t= "C8",
                    maxdiff=0.5,
                    matchall=True,
                    constraints=None,
                    numsources=None) -> List[Note]:
    """
    Find notes that, when ringmodulated together, produce the given sidebands

    Args:
        sidebands: a seq. of sidebands, as notenames or frequencies
        minnote, maxnote: limit the possible range of the sourcefreqs
        matchall: if True, all sidebands should be matched
        constraints: if given, a seq. of functions. Each of these constraints is of
                     the form (midisources, sidebands) -> bool
                     where: midisources: the sources being modulated (as midinotes)
                            sidebands: the sidebands generated (as midinote)

    Returns:
        a list of note which, when ringmodulated, produce the given sidebands

    Example
    ~~~~~~~

    Find a seq. of frequencies which generate the folowing sidebands, given that
    all sidebands should lie within the interval C2-C6

    >>> sidebands = ["C4", "E4", "B5"]
    >>> constraints = [lambda freqs: all(n2f("C2") <= freq <= n2f("C6") for freq in freqs)]
    >>> sourcefreqs = ringmod_sources(sidebands, matchall=True, constraints=constraints)
    >>> print(map(f2n, sourcefreqs))
    ['2C#', '4E', '5E']
    >>> newsidebands = ringmod(*sourcefreqs)
    >>> print(map(f2n, newsidebands))
    ['4C-09', '4E', '4G+30', '5D+08', '5Gb-27', '5B+02']
    """
    assert isinstance(sidebands, (list, tuple))
    sidemidis = [asmidi(sb) for sb in sidebands]
    midi0, midi1 = n2m(minnote), n2m(maxnote)
    if len(sidebands) == 2 and (numsources == 2 or numsources is None):
        note1, note2 = ringmod_exactsource(sidebands[0], sidebands[1])
        return [note1, note2]
    elif len(sidebands) > 6 or numsources is not None and numsources > 3:
        raise NotImplementedError("too many sidebands...")
    bestmatch = []
    sourcefreqs = None
    for m0, m1, m2 in combinations(range(int(midi0), int(ceil(midi1))), 3):
        newbands = ringmod(m0, m1, m2)
        newmidis = [band.pitch for band in newbands]
        matching = _matchone(sidemidis, newmidis, maxdiff)
        if not matching:
            continue
        elif matchall and len(matching) < len(sidebands):
            continue
        elif constraints and not all(constr([m0, m1, m2], newmidis)
                                     for constr in constraints):
            continue
        if len(matching) > len(bestmatch):
            bestmatch = matching
            sourcefreqs = [m2f(m) for m in newmidis]
        elif len(matching) == len(bestmatch):
            newdiff = sum(abs(orig-new) for orig, new in matching)
            lastdiff = sum(abs(orig-last) for orig, last in bestmatch)
            if newdiff < lastdiff:
                sourcefreqs = [m2f(m) for m in newmidis]
                bestmatch = matching
    return [Note(f2m(freq)) for freq in sourcefreqs]
    
        
SumTone = _namedtuple("SumTone", "notes sumnote sumfreq error")


def sumtones_sources(result, maxdist=0.5, maxnote="C8",
                     intervals=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                     show=False, minnote="A0", difftonegap=0):
    """
    find two notes which produce a sumation tone near the given note

    Args:
        result: the resulting difference tone, as note
        maxdist: the maximum distance between the expected result and the generated tone,
            in semitones (0.5 == 50 cents)
        maxnote: the highest note to considere
        intervals: accepted intervals between the notes. Only 'tempered' notes are used,
            but of course microtones produce also difference tones!
        minnote: the min. note to considere as source
        difftonegap : minimum gap (absolute value) between the sumtone and the difftone
            produced by the two notes
        show: either False or one of:
            'report': produce a text report
            'musicxml': convert to musicxml, show as Finale file
            'lily': convert to lilypond, show as PDF
    """
    result = asmidi(result)
    maxnote = asmidi(maxnote)
    pairs = _sumtone_find_source(result, maxdist, minnote=minnote, maxnote=maxnote,
                                 intervals=intervals, difftonegap=difftonegap)
    if not pairs:
        if show == 'report':
            import warnings
            warnings.warn("No source pair of notes found that satisfy the given conditions")
        return []
    out = []
    resultfreq = m2f(result)
    for note0, note1 in pairs:
        sumfreq = n2f(note0) + n2f(note1)
        sumtone = SumTone((note0, note1), f2n(sumfreq), sumfreq, abs(sumfreq-resultfreq))
        out.append(sumtone)
    if show == 'report':
        raise NotImplementedError()
        # _sumtones_sources_report(result, out)
    elif show:
        from maelzel import scoring
        events = []
        for pair in out:
            notes = []
            notes.extend(pair.notes)
            notes.append(pair.sumnote)
            chord = scoring.Notation(pitches=notes)
            chord.addArticulation('sum: %.2f' % pair.sumfreq)
            events.append(chord)
        r = scoring.render.render(events)
        r.show()
    return RecordList(out)


def wave_overtone_relative_amplitude(wavetype="saw", overtone=2) -> float:
    """
    Return the relative amplitude of the overtone given the wavetype

    Available wavetypes are: saw, sine, square, and tri (triangle)
    """
    if overtone <= 0:
        raise ValueError("Overtone should be >= 1 (f0 = overtone 1)")
    if wavetype == "saw":
        return 1/overtone 
    elif wavetype == "square":
        return 1 / overtone * (overtone % 2)
    elif wavetype == "sine":
        return 1 if overtone == 1 else 0
    elif wavetype == "tri":
        return 1 / (overtone**2) * (overtone % 2)
    else:
        raise KeyError("wavetype not known, should be one of saw, square, sine or tri")
    

# #------------------------------------------------------------
# #
# #    estimate beatings
# #
# #------------------------------------------------------------


class DifftoneBeating(NamedTuple):
    beatings: float
    note1: Note
    note2: Note
    freq1: float
    freq2: float
    relamp: float

    def __repr__(self):
        return "Beatings: %.2f   between overtone %d (%s)" \
               "and overtone %d (%s) -- relamp: %.3f" % \
               (self.beatings, int(self.note1.freq / self.freq1 + 0.5), self.note1.name, 
                int(self.note2.freq / self.freq2 + 0.5), self.note2.name, self.relamp)


def difftones_beatings(pitch1: pitch_t, pitch2: pitch_t, maxbeatings=20, minbeatings=0.3, wave="saw",
                       ) -> List[DifftoneBeating]:
    """
    estimate the beatings generated by the difference tone(s) between note1 and note2
    
    for each pair of notes other than sinus-tones, many difference tones are generated:
       * between the fundamentals
       * between the overtones
    
    The calculation is based on the relative amplitude of the overtones and presuposes
    simple waveforms. Any other routine would have to work with the actual sample data
    to calculate the beatings.
    
    Using saw waves gives a sort of upper limit to the beatings which can be generated
    between two notes. In reality, the amplitude of the beatings will always be less than
    what is reported here.
    """
    defaultwave = wave
    freq1 = m2f(asmidi(pitch1))
    freq2 = m2f(asmidi(pitch2))
    overtones1 = [freq1 * i for i in range(1, 7)]
    overtones2 = [freq2 * i for i in range(1, 7)]
    pairs = []
    for i, o1 in enumerate(overtones1):
        for j, o2 in enumerate(overtones2):
            if minbeatings <= abs(o1 - o2) <= maxbeatings:
                amp1 = wave_overtone_relative_amplitude(defaultwave, i)
                amp2 = wave_overtone_relative_amplitude(defaultwave, j)
                amp = amp1 * amp2
                if amp > 0:
                    pairs.append((amp, o1, o2))
    pairs.sort(reverse=True)
    pairs2 = [DifftoneBeating(abs(o1-o2), Note(f2m(o1)), Note(f2m(o2)), freq1, freq2, amp)
              for amp, o1, o2 in pairs]
    return pairs2


def fm_sidebands(carrierfreq:float, modfreq:float, index:float, minamp=0.01,
                 minfreq=0, maxfreq=0) -> List[Tuple[float, float]]:
    """
    Returns a list of bands with min. amp at the given modulation index

    Args:
        carrierfreq: the fm carrier frequency
        modfreq: the fm modulation frequency
        index: the fm modulation index
        minamp: min. relative amp
        minfreq: min. sideband frequency
        maxfreq: max. sideband frequency

    Returns:
        a list of sidebands, where a sideband is a tuple (freq, amp)
    """
    # calcular las amplitudes con scipy.special.jv(n, index),
    # donde n es el indice de la banda
    from scipy.special import jv
    bands = []
    for n in range(0, 200):
        freq0 = carrierfreq + modfreq*n
        amp = abs(jv(n, index))
        freq1 = abs(carrierfreq - modfreq*n)
        if amp > minamp:
            bands.append((freq0, amp))
            if freq1 != freq0 and freq1 > 0:
                bands.append((freq1, amp))
    bands.sort()
    if minfreq > 0 or maxfreq > 0:
        maxfreq = maxfreq if maxfreq > 0 else 24000
        bands = [band for band in bands if minfreq <= band[0] < maxfreq]
    return bands


def _checkpitch(p: Union[str, int, float]) -> bool:
    if isinstance(p, str):
        return True
    if isinstance(p, (int, float)):
        if p > 127:
            raise ValueError(f"Expected a pitch (a notename or a midinote) but got {p}")
        return True
    raise TypeError(f"Expected a str or a float, but got {type(p)}")


def fm_chord(carrierfreq: float, modfreq: float, index: float, minamp=0.01,
             minpitch=None, maxpitch=None) -> Chord:
    maxfreq = 24000 if maxpitch is None else asNote(maxpitch).freq
    minfreq = 0 if minpitch is None else asNote(minpitch).freq
    bands = fm_sidebands(carrierfreq=carrierfreq, modfreq=modfreq, index=index,
                         minamp=minamp, minfreq=minfreq, maxfreq=maxfreq)
    notes = [Note(f2m(freq), amp=amp) for freq, amp in bands]
    return Chord(notes)
    

def fm_chord_ratio(carrier: pitch_t, ratio: float, index: float, minamp=0.01,
                   minpitch=None, maxpitch=None) -> Chord:
    carrierfreq = asNote(carrier).freq
    modfreq = carrierfreq * ratio
    return fm_chord(carrierfreq=carrierfreq, modfreq=modfreq, index=index,
                    minamp=minamp, minpitch=minpitch, maxpitch=maxpitch)


def difftone_evaluate_inharmonicity(pitch1: pitch_t, pitch2: pitch_t) -> float:
    m1 = asmidi(pitch1)
    m2 = asmidi(pitch2)
    if m1 > m2:
        m1, m2 = m2, m1
    md = f2m(abs(m2f(m1) - m2f(m2)))
    f1, f2, fd = map(m2f, (m1, m2, md))
    rat_2_1 = f2/f1
    rat_2_d = f2/fd
    rat_1_d = f1/fd
    ratq_2_1 = misc.snap_to_grid(rat_2_1, 0.5)
    ratq_2_d = misc.snap_to_grid(rat_2_d, 0.5)
    ratq_1_d = misc.snap_to_grid(rat_1_d, 0.5)
    delta_2_1 = abs(rat_2_1 - ratq_2_1) / rat_2_1
    delta_2_d = abs(rat_2_d - ratq_2_d) / rat_2_d
    delta_1_d = abs(rat_1_d - ratq_1_d) / rat_1_d
    print(delta_2_1, delta_2_d, delta_1_d)
    delta = sqrt(delta_2_1**2 + delta_2_d**2 + delta_1_d**2)
    return delta