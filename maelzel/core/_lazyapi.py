from __future__ import annotations

import typing as _t
if _t.TYPE_CHECKING:
    from maelzel.core import synthevent
    from maelzel.core.offline import OfflineRenderer
    import csoundengine.event
    from maelzel.core import mobj
    from maelzel.core.workspace import Workspace


def render(outfile='',
           events: _t.Sequence[synthevent.SynthEvent | mobj.MObj | csoundengine.event.Event | _t.Sequence[mobj.MObj | synthevent.SynthEvent]] = (),
           sr=0,
           wait: bool | None = None,
           ksmps=0,
           verbose: bool | None = None,
           nchnls: int | None = None,
           workspace: Workspace | None = None,
           tail: float | None = None,
           run=True,
           endtime=0.,
           show=False,
           **kws
           ) -> OfflineRenderer:
    """
    Render to a soundfile / creates a **context manager** to render offline

    When not used as a context manager the events / objects must be given. The soundfile
    will be generated immediately.

    When used as a context manager the `events` argument should be left unset.
    Within this context any call to :meth:`maelzel.core.MObj.play` will be redirected to
    the offline renderer and at the exit of the context all events will be rendered to a
    soundfile. Also, any pure csound events scheduled via ``playSession()._sched(...)``
    will also be redirected to be renderer offline.

    This enables to use the exact same code when doing realtime and offline rendering.

    Args:
        outfile: the generated file. If None, a file inside the recording
            path is created (see `recordPath`). Use "?" to save via a GUI dialog or
        events: the events/objects to play. This can only be left unset if using ``render``
            as a context manager (see example).
        sr: sample rate of the soundfile (:ref:`config 'rec.sr' <config_rec_sr>`)
        ksmps: number of samples per cycle (:ref:`config 'rec.ksmps' <config_rec_ksmps>`)
        nchnls: number of channels of the rendered soundfile
        wait: if True, wait until recording is finished. If None,
            use the :ref:`config 'rec.blocking' <config_rec_blocking>`
        verbose: if True, show the output generated by the csound subprocess
        tail: extra time added at the end of the render, usefull when rendering reverbs or
            long decaying sound. If None, uses use :ref:`config 'rec.extratime' <config_rec_extratime>`
        run: if True, perform the render itself
        tail: extra time at the end, usefull when rendering reverbs or long deaying sounds
        endtime: if given, sets the end time of the rendered segment. A value
            of 0. indicates to render everything. A value is needed if there
            are endless events
        show: display the resulting OfflineRenderer when running inside jupyter
        workspace: if given, this workspace overrides the active workspace

    Returns:
        the :class:`OfflineRenderer` used to render the events. If the outfile
        was not given, the path of the recording can be retrieved from
        ``renderer.outfile``

    Example
    ~~~~~~~

        >>> a = Chord("A4 C5", start=1, dur=2)
        >>> b = Note("G#4", dur=4)
        >>> render("out.wav", events=[
        ...     a.synthEvents(chain=1),
        ...     b.synthEvents(chan=2, gain=0.2)
        ... ])

    This function can be also used as a context manager, similar to
    :func:`maelzel.playback.play`. In that case `events` must be ``None``:

        >>> from maelzel.core import *
        >>> scale = Chain([Note(n) for n in "4C 4D 4E 4F 4G".split()])
        >>> playSession().defInstr('reverb', r'''
        ... |kfeedback=0.6|
        ... amon1, amon2 monitor
        ... a1, a2 reverbsc amon1, amon2, kfeedback, 12000, sr, 0.6
        ... outch 1, a1-amon1, 2, a2-amon2
        ... ''')
        >>> with render() as r:
        ...     scale.play('.piano')   # .play here is redirected to the offline renderer
        ...     r.sched('reverb', priority=2)


    .. seealso:: :class:`OfflineRenderer`, :func:`maelzel.playback.play`
    """
    from maelzel.core import offline
    return offline.render(outfile=outfile, events=events, sr=sr, wait=wait, ksmps=ksmps, nchnls=nchnls,
                          workspace=workspace, verbose=verbose, tail=tail,
                          run=run, endtime=endtime, show=show, **kws)
