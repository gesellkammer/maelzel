"""
This module handles playing of events

Each Note, Chord, Line, etc, can express its playback in terms of CsoundEvents

A CsoundEvent is a score line with a number of fixed fields,
user-defined fields and a sequence of breakpoints

A breakpoint is a tuple of values of the form (offset, pitch [, amp, ...])
The size if each breakpoint and the number of breakpoints are given
by inumbps, ibplen

An instrument to handle playback should be defined with `defPreset` which handles
breakpoints and only needs the audio generating part of the csound code.

Whenever a note actually is played with a given preset, this preset is
 sent to the csound engine and instantiated/evaluated.

Examples
~~~~~~~~

.. code::

    from maelzel.core import *
    f0 = n2f("1E")
    notes = [Note(f2m(i*f0), dur=0.5) for i in range(20)]
    play.defPreset("detuned", r'''

    ''')

"""
from __future__ import annotations
import os

from datetime import datetime

from ._common import logger
from . import _util
from . import tools
from .presetbase import *
from .presetman import presetManager, _csoundPrelude as _prelude
from .errors import *
from .workspace import getConfig, getWorkspace, recordPath
import csoundengine
from .csoundevent import CsoundEvent

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from typing import *
    from .musicobjbase import MusicObj
    from maelzel.snd import audiosample


__all__ = ('OfflineRenderer',
           'playEvents',
           'recEvents')


_invalidVariables = {"kfreq", "kamp", "kpitch"}


class OfflineRenderer:
    """
    An OfflineRenderer is created to render musical objects to a soundfile

    .. admonition:: OfflineRenderer as context manager

        The most simple way to render offline is to use an OfflineRenderer
        as a context manager. Within this context any .play call will be
        collected and everything will be rendered when exiting the context
        (see example below: :ref:`example<offlineRendererExample>`)

    Args:
        outfile: the path to the rendered soundfile. If not given a path
            within the recordPath() is returned
        sr: the samplerate of the render (config: 'rec.sr')
        ksmps: the ksmps used for the recording
        quiet: if True, debugging output is minimized. If None, defaults to
            config (key: 'rec.quiet')

    .. _offlineRendererExample:

    Example
    ~~~~~~~

        # Render a chromatic scale.
        >>> from maelzel.core import *
        >>> notes = [Note(n, dur=0.5) for n in range(48, 72)]
        >>> chain = Chain(notes)
        >>> defPresetSoundfont('piano', sf2path='/path/to/piano.sf2')
        >>> with play.OfflineRenderer('scale.wav') as r:
        ...     chain.play(instr='piano')

    When exiting the context manager the file 'scale.wav' is rendered. During
    the context manager, all calls to .play are intersected and scheduled
    via the OfflineRenderer

    """
    def __init__(self, outfile:str=None, sr=None, ksmps=64, nchnls=2, quiet:bool=None):
        w = getWorkspace()
        cfg = getConfig()
        if outfile is not None and outfile != "?":
            outfile = _util.normalizeFilename(outfile)
        self.outfile = outfile
        self.a4 = w.a4
        self.sr = sr or cfg['rec.sr']
        self.quiet = quiet
        self.ksmps = ksmps
        self.renderer = presetManager.makeRenderer(sr, ksmps=ksmps, nchnls=nchnls)
        self.events: List[CsoundEvent] = []
        self.instrDefs: Dict[str, csoundengine.Instr] = {}
        self.renderedSoundfiles: List[str] = []

    def _repr_html_(self) -> str:
        if not self.renderedSoundfiles:
            return str(self)
        sndfile = self.renderedSoundfiles[-1]
        if not os.path.exists(sndfile):
            return str(self)
        from maelzel.snd import audiosample
        from maelzel import colortheory
        sample = audiosample.Sample(sndfile)
        samplehtml = sample.reprHtml()
        blue = colortheory.safeColors['blue1']
        header = f'<strong>OfflineRenderer</strong>(outfile=<code style="color:{blue}">"{self.outfile}"</code>)'
        return '<br>'.join([header, samplehtml])

    def registerInstr(self, instrname: str, instrdef: csoundengine.Instr) -> None:
        """
        Register a csoundengine.Instr to be used with this OfflineRenderer

        Args:
            instrname: the name of this preset/instrument
            instrdef: the csoundengine.Instr instance

        """
        self.instrDefs[instrname] = instrdef
        self.renderer.registerInstr(instrdef)

    def play(self, obj: MusicObj, **kws) -> List[csoundengine.offline.ScoreEvent]:
        """
        Schedule the events generated by this obj to be renderer offline

        Args:
            obj: the object to be played offline
            kws: any keyword passed to the .events method of the obj

        Returns:
            the offline score events
        """
        events = obj.events(**kws)
        scoreEvents = [self.schedEvent(ev) for ev in events]
        return scoreEvents

    def schedEvent(self, event: CsoundEvent) -> csoundengine.offline.ScoreEvent:
        """
        Schedule a CsoundEvent as returned by MusicObj.events()

        Args:
            event: a CsoundEvent, as returned

        Returns:
            a ScoreEvent

        See Also:
            sched
        """
        # NB: the instrname is actually the preset name.
        instrname = event.instr
        instrdef = self.instrDefs.get(instrname)
        if instrdef is None:
            preset = presetManager.getPreset(instrname)
            if not preset:
                raise ValueError(f"Unknown instr: {instrname}")
            instrdef = preset.getInstr()
            self.registerInstr(instrname, instrdef)
        args = event.resolvePfields(instrdef)
        return self.renderer.sched(instrdef.name, delay=event.delay, dur=event.dur,
                                   pargs=args[3:], priority=event.priority,
                                   tabargs=event.namedArgs)

    def definedInstrs(self) -> Dict[str, csoundengine.Instr]:
        """
        Get all instruments available within this OfflineRenderer

        All presets and all extra intruments registered at the active
        Session (as returned via getPlaySession) are available

        Returns:
            dict {instrname: csoundengine.Instr} with all instruments available

        """
        instrs = {}
        instrs.update(self.renderer.registeredInstrs())
        instrs.update(getPlaySession().registeredInstrs())
        return instrs

    def sched(self,
              instrname: str,
              delay=0.,
              dur=-1.,
              priority=1,
              pargs: Union[List[float], Dict[str, float]] = None,
              tabargs: Dict[str, float] = None,
              **kws) -> csoundengine.offline.ScoreEvent:
        """
        Schedule a csound event

        This method should be used to schedule non-preset based instruments
        when rendering offline (things like global effects, for example),
        similarly to how a user might schedule a non-preset based instrument
        in real-time.

        Args:
            instrname: the instr. name
            delay: start time
            dur: duration
            priority: priority of the event
            pargs: any pargs passed to the instr., starting at p5
            tabargs: table args accepted by the instr.
            **kws: named pargs

        Returns:
            the offline.ScoreEvent, which can be used as a reference by other
            offline events

        Example
        ~~~~~~~

            >>> from maelzel.core import *
            >>> scale = Chain([Note(n) for n in "4C 4D 4E 4F 4G".split()])
            >>> play.getPlaySession().defInstr('reverb', r'''
            ... |kfeedback=0.6|
            ... amon1, amon2 monitor
            ... a1, a2 reverbsc amon1, amon2, kfeedback, 12000, sr, 0.6
            ... outch 1, a1-amon1, 2, a2-amon2
            ... ''')
            >>> presetManager.defPresetSoundfont('piano', '/path/to/piano.sf2')
            >>> with play.OfflineRenderer() as r:
            ...     r.sched('reverb', priority=2)
            ...     scale.play('piano')

        """
        if not self.renderer.isInstrDefined(instrname):
            session = getPlaySession()
            instr = session.getInstr(instrname)
            if not instr:
                logger.error(f"Unknown instrument {instrname}. "
                             f"Defined instruments: {self.renderer.registeredInstrs().keys()}")
                raise ValueError(f"Instrument {instrname} unknown")
            self.renderer.registerInstr(instr)
        return self.renderer.sched(instrname=instrname, delay=delay, dur=dur,
                                   priority=priority, pargs=pargs,
                                   tabargs=tabargs,
                                   **kws)


    def render(self, outfile:str=None, wait=None, quiet=None, openWhenDone=False
               ) -> str:
        """
        Render the events scheduled until now.

        Args:
            outfile: the soundfile to generate. Use "?" to save via a GUI dialog,
                None will render to a temporary file
            wait: if True, wait until rendering is done
            quiet: if True, supress all output generated by csound itself
                (print statements and similar opcodes still produce output)
            openWhenDone: if True, open the rendered soundfile in the default
                application

        Returns:
            the path of the renderer file
        """
        cfg = getConfig()
        if outfile is None:
            outfile = self.outfile
        if outfile == '?':
            outfile = tools.saveRecordingDialog()
            if not outfile:
                raise CancelledError("Render operation was cancelled")
        elif not outfile:
            outfile = _makeRecordingFilename(ext=".wav")
        outfile = _util.normalizeFilename(outfile)
        self.renderedSoundfiles.append(outfile)
        if quiet is None:
            quiet = self.quiet if self.quiet is not None else cfg['rec.quiet']
        self.renderer.render(outfile=outfile, wait=wait, quiet=quiet,
                             openWhenDone=openWhenDone)
        return outfile

    def getCsd(self) -> str:
        """
        Return the .csd as string
        """
        return self.renderer.generateCsdString()

    def writeCsd(self, outfile: str = '?') -> str:
        """
        Write the .csd which would render all events scheduled until now

        Args:
            outfile: the path of the saved .csd

        Returns:
            the outfile
        """
        if outfile == "?":
            outfile = tools.selectFileForSave("saveCsdLastDir", filter="Csd (*.csd)")
            if not outfile:
                raise CancelledError("Save operation cancelled")
        self.renderer.writeCsd(outfile)
        return outfile

    def __enter__(self):
        workspace = getWorkspace()
        self._oldRenderer = workspace.renderer
        workspace.renderer = self
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is not None:
            # There was an exception since entering
            logger.warning("Offline rendering aborted")
            return
        w = getWorkspace()
        w.renderer = self._oldRenderer
        if self.outfile is None:
            self.outfile = _makeRecordingFilename()
            logger.info(f"Rendering to {self.outfile}")
        self.render(outfile=self.outfile, wait=True)

    def renderedSample(self) -> audiosample.Sample:
        """
        Returns the last rendered soundfile as an :class:`maelzel.snd.audiosample.Sample`
        """
        assert self.renderedSoundfiles
        lastsnd = self.renderedSoundfiles[-1]
        assert os.path.exists(lastsnd)
        from maelzel.snd import audiosample
        return audiosample.Sample(lastsnd)

    def openRenderedSoundfile(self) -> None:
        """
        Opens the rendered soundfile in the default external app
        """
        if not self.renderedSoundfiles:
            raise RuntimeError("No soundfile rendered yet")
        sndfile = self.renderedSoundfiles[-1]
        if not os.path.exists(sndfile):
            raise RuntimeError(f"Did not find rendered file {sndfile}")
        import emlib.misc
        emlib.misc.open_with_app(sndfile)


def recEvents(events: List[CsoundEvent], outfile:str=None,
              sr:int=None, wait:bool=None, ksmps: int = None,
              quiet: bool = None, nchnls: int = None
              ) -> str:
    """
    Record the events to a soundfile

    Args:
        events: a list of events as returned by .events(...)
        outfile: the generated file. If left unset, a file inside the recording
            path is created (see `recordPath`). Use "?" to save via a GUI dialog
        sr: sample rate of the soundfile
        ksmps: number of samples per cycle (config 'rec.ksmps')
        wait: if True, wait until recording is finished. If None,
            use the config 'rec.block'
        quiet: if True, supress debug information when calling
            the csound subprocess

    Returns:
        the path of the generated soundfile

    Example::

        a = Chord("A4 C5", start=1, dur=2)
        b = Note("G#4", dur=4)
        events = sum([
            a.events(chan=1),
            b.events(chan=2, gain=0.2)
        ], [])
        recEvents(events, outfile="out.wav")

    See Also
    ~~~~~~~~

    :class:`OfflineRenderer`
    """
    if nchnls is None:
        nchnls = max(round(ev.position + ev.chan) for ev in events)
    offlineRenderer = OfflineRenderer(sr=sr, ksmps=ksmps, nchnls=nchnls)
    for ev in events:
        offlineRenderer.schedEvent(ev)
    return offlineRenderer.render(outfile=outfile, wait=wait, quiet=quiet)


def _path2name(path):
    return os.path.splitext(os.path.split(path)[1])[0].replace("-", "_")


def _makeRecordingFilename(ext=".wav", prefix="rec-"):
    """
    Generate a new filename for a recording.

    This is used when rendering and no outfile is given

    Args:
        ext: the extension of the soundfile (should start with ".")
        prefix: a prefix used to identify this recording

    Returns:
        an absolute path. It is guaranteed that the filename does not exist.
        The file will be created inside the recording path (see ``state.recordPath``)
    """
    path = recordPath()
    assert ext.startswith(".")
    base = datetime.now().isoformat(timespec='milliseconds')
    if prefix:
        base = prefix + base
    out = os.path.join(path, base + ext)
    assert not os.path.exists(out)
    return out


def _registerPresetInSession(preset: PresetDef,
                             session:csoundengine.session.Session
                             ) -> csoundengine.Instr:
    """
    Create and register a :class:`csoundengine.instr.Instr` from a preset

    Args:
        preset: the PresetDef.
        session: the session to manage the instr

    Returns:
        the registered Instr
    """
    # each preset caches the generated instr
    instr = preset.getInstr()
    # registerInstr checks itself if the instr is already defined
    session.registerInstr(instr)
    return instr


def _soundfontToTabname(sfpath: str) -> str:
    path = os.path.abspath(sfpath)
    return f"gi_sf2func_{hash(path)%100000}"


def _soundfontToChannel(sfpath:str) -> str:
    basename = os.path.split(sfpath)[1]
    return f"_sf:{basename}"


def startPlayEngine(numChannels: int = None,
                    backend: str = None,
                    verbose: bool = None,
                    buffersize: int = None) -> csoundengine.Engine:
    """
    Start the play engine

    If an engine is already active, nothing happens, even if the
    configuration is different. To start the play engine with a different
    configuration, stop the engine first.

    Args:
        numChannels: the number of output channels, overrides config 'play.numChannels'
        backend: the audio backend used, overrides config 'play.backend'
        verbose: if True, output debugging information
        buffersize: if given, use this as the buffer size. None to use a sensible
            default for the backend
    """
    config = getConfig()
    engineName = config['play.engineName']
    if engineName in csoundengine.activeEngines():
        return csoundengine.getEngine(engineName)
    numChannels = numChannels or config['play.numChannels']
    if backend == "?":
        backends = [b.name for b in csoundengine.csoundlib.audioBackends(available=True)]
        backend = tools.selectFromList(backends, title="Select Backend")
    backend = backend or config['play.backend']
    verbose = verbose if verbose is not None else config['play.verbose']
    logger.debug(f"Starting engine {engineName} (nchnls={numChannels})")
    return csoundengine.Engine(name=engineName,
                               nchnls=numChannels,
                               backend=backend,
                               globalcode=_prelude,
                               quiet=not verbose,
                               latency=config['play.schedLatency'],
                               buffersize=buffersize)


def stopSynths(stopengine=False, cancelfuture=True):
    """
    Stops all synths (notes, chords, etc) being played

    If stopengine is True, the play engine itself is stopped
    """
    session = getPlaySession()
    session.unschedAll(future=cancelfuture)
    if stopengine:
        getPlayEngine().stop()


def getPlaySession() -> csoundengine.Session:
    config = getConfig()
    group = config['play.engineName']
    if not isEngineActive():
        if config['play.autostartEngine']:
            startPlayEngine()
        else:
            raise RuntimeError("Engine is not running and config['play.autostartEngine'] "
                               "is False. Call startPlayEngine")
    return csoundengine.getSession(group)


def isEngineActive() -> bool:
    """
    Returns True if the sound engine is active
    """
    name = getConfig()['play.engineName']
    return csoundengine.getEngine(name) is not None


def getPlayEngine(start=None) -> Optional[csoundengine.Engine]:
    """
    Return the sound engine, or None if it has not been started
    """
    cfg = getConfig()
    engine = csoundengine.getEngine(name=cfg['play.engineName'])
    if not engine:
        logger.debug("engine not started")
        start = start if start is not None else cfg['play.autostartEngine']
        if start:
            engine = startPlayEngine()
            return engine
        return None
    return engine


def lockedClock():
    """
    Context manager to schedule play events in sync.

    This is a shortcut to ``play.getPlayEngine().lockedClock()``

    Example
    -------

        >>> from maelzel.core import *
        >>> notes = [Note(m, dur=1) for m in range(60, 72)]
        >>> with play.lockedClock():
        ...     for i, n in enumerate(notes):
        ...         n.play(delay=i*0.25, instr='.piano')

    """
    return getPlayEngine().lockedClock()


def _schedOffline__(renderer: csoundengine.Renderer,
                  events: List[CsoundEvent],
                  _checkNchnls=True
                  ) -> None:
    """
    Schedule the given events for offline rendering.

    You need to call renderer.render(...) to actually render/play the
    scheduled events

    Args:
        renderer: a Renderer as returned by makeRenderer
        events: events as returned by, for example, chord.events(**kws)
        _checkNchnls: (internal parameter)
            if True, will check (and adjust) nchnls in
            the renderer so that it is high enough for all
            events to render properly
    """
    # Deprecated
    raise RuntimeError("This function is deprecated")
    if _checkNchnls:
        maxchan = max(presetManager.eventMaxNumChannels(event)
                      for event in events)
        if renderer.nchnls < maxchan:
            logger.info(f"_schedOffline: the renderer was defined with "
                        f"nchnls={renderer.csd.nchnls}, but {maxchan} "
                        f"are needed to render the given events. "
                        f"Setting nchnls to {maxchan}")
            renderer.csd.nchnls = maxchan
    for event in events:
        instrName = event.instr
        assert instrName is not None
        presetdef = presetManager.getPreset(instrName)
        instr = presetdef.getInstr()
        if not renderer.isInstrDefined(instr.name):
            instr = presetdef.getInstr()
            renderer.registerInstr(instr)
        # renderer.defInstr(instrName, body=presetdef.body, tabledef=presetdef.params)
        pargs = event.resolvePfields(instr)
        if pargs[2] != 0:
            logger.warn(f"got an event with a tabnum already set...: {pargs}")
            logger.warn(f"event: {event}")
        renderer.sched(instrName, delay=pargs[0], dur=pargs[1],
                       pargs=pargs[3:],
                       tabargs=event.namedArgs,
                       priority=event.priority)


def playEvents(events: List[CsoundEvent],
               whenfinished: Callable = None
               ) -> csoundengine.synth.SynthGroup:
    """
    Play a list of events

    Args:
        events: a list of CsoundEvents
        whenfinished: call this function when the last event is finished. A function taking
            no arguments and returning None

    Returns:
        A SynthGroup

    Example::

        from maelzel.core import *
        group = Group([
            Note("4G", dur=8),
            Chord("4C 4E", dur=7, start=1)
            Note("4C#", start=1.5, dur=6)])
        play.playEvents(group.events(instr='.piano')
    """
    synths = []
    session = getPlaySession()
    presetNames = {ev.instr for ev in events}
    presetDefs = [presetManager.getPreset(name) for name in presetNames]
    presetToInstr: Dict[str, csoundengine.Instr] = {}
    sync = False
    for preset in presetDefs:
        instrdef = preset.getInstr()
        presetToInstr[preset.name] = instrdef
        if not session.isInstrRegistered(instrdef):
            sync = True
            session.registerInstr(instrdef)

    if sync:
        session.engine.sync()

    # We take a reference time before starting scheduling,
    # so we can guarantee that events which are supposed to be
    # in sync, are in fact in sync. We could use Engine.lockReferenceTime
    # but we might interfere with another called doing the same.
    elapsed = session.engine.elapsedTime() + session.engine.extraLatency
    if whenfinished:
        ev = max(events, key=lambda ev: ev.end if ev.end > 0 else float('inf'))
        ev.whenfinished = lambda id: whenfinished() if not ev.whenfinished else lambda id, ev=ev: ev.whenfinished(id) or whenfinished()
    for ev in events:
        instr = presetToInstr[ev.instr]
        args = ev.resolvePfields(instr)
        synth = session.sched(instr.name,
                              delay=args[0]+elapsed,
                              dur=args[1],
                              pargs=args[3:],
                              tabargs=ev.namedArgs,
                              priority=ev.priority,
                              relative=False,
                              whenfinished=ev.whenfinished)
        synths.append(synth)
    group = csoundengine.synth.SynthGroup(synths)
    return group


def _resolvePfields(event: CsoundEvent, instr: csoundengine.Instr
                    ) -> List[float]:
    """
    returns pfields, **beginning with p2**.

    ==== =====  ======
    idx  parg    desc
    ==== =====  ======
    0    2       delay
    1    3       duration
    2    4       tabnum
    3    5       bpsoffset (pfield index, starting with 1)
    4    6       bpsrows
    5    7       bpscols
    6    8       gain
    7    9       chan
    8    0       position
    9    1       fade0
    0    2       fade1
    1    3       pitchinterpol
    2    4       fadeshape
    .
    . reserved space for user pargs
    .
    ==== =====  ======

    breakpoint data

    tabnum: if 0 it is discarded and filled with a valid number later
    """
    pitchInterpolMethod = CsoundEvent.pitchinterpolToInt[event.pitchInterpolMethod]
    fadeshape = CsoundEvent.fadeshapeToInt[event.fadeShape]
    # if no userpargs, bpsoffset is 15
    numPargs5 = len(instr.pargsIndexToName)
    numBuiltinPargs = 10
    numUserArgs = numPargs5 - numBuiltinPargs
    bpsoffset = 15 + numUserArgs
    bpsrows = len(event.bps)
    bpscols = event.breakpointSize()
    pfields = [
        float(event.delay),
        event.dur,
        0,  # table index, to be filled later
    ]
    pfields5 = [
        bpsoffset, # p5, idx: 4
        bpsrows,
        bpscols,
        event.gain,
        event.chan,
        event.position,
        event.fadein,
        event.fadeout,
        pitchInterpolMethod,
        fadeshape
    ]
    print("# user args: ", numUserArgs, "len pfields5", len(pfields5))

    if event._namedArgsMethod == 'pargs' and numUserArgs > 0:
        pfields5 = instr.pargsTranslate(args=pfields5, kws=event.namedArgs)
    pfields.extend(pfields5)
    for bp in event.bps:
        pfields.extend(bp)

    assert all(isinstance(p, (int, float)) for p in pfields), [(p, type(p)) for p in pfields if not isinstance(p, (int, float))]
    return pfields